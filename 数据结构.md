# ==数据结构==

## 基本概念

### 数据结构

解决方法的效率，跟**数据的组织方式有关**，也跟**空间利用效率有关**,也跟**算法巧妙程度有关**

e.g.计算多项式

```java
// 一般方式
public double m1(int n, double[] a, double x) {
    double res = 0;
    for(int i=0; i < a.length(); i++) {
        res += a[i] * Math.pow(x,i);
    }
    return res;
}

// 秦九韶算法
public double m2(int n, double[] a, double x) {
    double res = a[n];
    for(int i=n; i > 0; i--) {
        res = a[i-1] + res * x;
    }
    return res;
}
```

- **数据对象**是在计算机中的组织方式
  - 逻辑结构
  - 物理存储结构
- 数据对象必须与一系列加在其上的操作相关联，这些操作称为**算法**

**抽象数据类型(Abstract Data Type)**

- 抽象：描述数据类型的方法不依赖于具体实现
  - 与存放数据机器无关
  - 与数据存储的物理结构无关
  - 与实现操作的算法和编程语言无关

- 数据类型
  - 数据对象集
  - 数据集合相关操作集

只描述数据对象集和相关操作集**是什么**，并不涉及**如何实现**问题

e.g.关于“矩阵”的抽象数据类型的定义

- 类型名称：矩阵(Matrix)

- 数据对象集：一个M×N矩阵A~M×N~=(a~ij~)(i=1,2...M;j=1,2...N)由M×N个三元组<a,i,j>组成，其中a是矩阵元素的值，i是元素所在行号，j是元素所在列号

- 操作集

  - 返回M×N的空矩阵
  - 返回矩阵A总行数
  - 返回矩阵A总列数
  - 返回矩阵A第i行第j列的元素
  - 如果A和B行列数已知，返回矩阵C=A+B，否则抛出异常
  - 如果A行数等于B列数，返回矩阵C=AB，否则抛出异常

### 算法

**定义**

- 算法(Alogorithm)

  - 有限指令集

  - 接收一定输入

  - 产生输出

  - 一定在有限步后终止

  - 每条指令必须

    - 有充分明确的目标，不可以有歧义
    - 在计算机能处理范围之内
    - 描述不依赖任何一种计算机语言以及具体的实现手段

    e.g.

    ```java
    void SelectionSort ( int List[], int N ){ /* 将N个整数List[0]...List[N-1]进行非递减排序 */
    	for ( i = 0; i < N; i ++ ) {
    		MinPosition = ScanForMin( List, i, N–1 ); 
    		/* 从List[i]到List[N–1]中找最小元，并将其位置赋给MinPosition */
    		Swap( List[i], List[MinPosition] );
    		/* 将未排序部分的最小元换到有序部分的最后位置 */
    	}
    }
    /*
     抽象体现：
     	List是数组还是列表？
     	swap是用函数还是宏？
     上述具体细节在描述算法时不关心
     */
    ```

**什么是好的算法**

- 空间复杂度S(n)——根据算法写成的程序在执行时**占用存储单元的长度**。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断

- 时间复杂度T(n)——根据算法写成的程序在执行时**耗费时间的长度**。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果

n用于描述数据的规模

在分析一般算法效率时，常关心以下两种复杂度

- 最坏复杂度T~worst~(n)
- 平均复杂度T~avg~(n)

​	T~avg~(n) ≤ T~worst~(n)



**复杂度的渐进表达式**

- T(n)=O(f(n)) 表示存在常数C>0,n~0~>0,使得当n>n~0~时有T(n)≤C*f(n)

- T(n)=Ω(g(n)) 表示存在常数C>0,n~0~>0,使得当n>n~0~时有T(n)≥C*g(n)

**log~n~	<	n	<	nlog~n~	<	n^2^	<	2^n^	<	n!**

T1(n) + T2(n) = max(O( f1(n)), O(f2(n)) ) 

T1(n) *T2 (n) = O( f1( n) * f2(n) )

- 一个**for**循环的时间复杂度等于循环次数乘以循环体代码的复杂度
- **if-else**结构的复杂度取决于if的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大



e.g.给定N个整数的序列{ A1, A2, …, AN}， 求连续最大子列和

**算法1**

```java
int MaxSubseqSum1( int A[], int N ){ 
    int ThisSum, MaxSum = 0;
	int i, j;
	for( i = 0; i < N; i++ ) { /* i是子列左端位置 */
		ThisSum = 0; /* ThisSum是从A[i]到A[j]的子列和 */
		for( j = i; j < N; j++ ) { /* j是子列右端位置 */
			ThisSum += A[j];
			/*对于相同的i，不同的j，只要在j-1次循环的基础上累加1项即可*/
			if( ThisSum > MaxSum ) /* 如果刚得到的这个子列和更大 */
				MaxSum = ThisSum; /* 则更新结果 */
		} /* j循环结束 */
	} /* i循环结束 */
	return MaxSum;
}
```

T(N)=O(N^2^)

**算法2**

分而治之

T(N)=O(Nlog~N~)

**算法3**

```java
int MaxSubseqSum2( int A[], int N ){
    int ThisSum,MaxSum = 0;
    for (int i = 0; i < N; i++) {
        ThisSum += A[i]; /* 向右累加 */
        if (ThisSum > MaxSum){ 
            MaxSum = ThisSum; /* 发现更大和则更新当前结果 */
        }
        else if (ThisSum < 0){ /* 如果当前ThisSum为负，即子列和为负，则不可能使后面的部分和增大，抛弃并重置ThisSum */
            ThisSum = 0;
        }
    }
}
```

T(N)=O(N)

**在线**的意思是指对每输入一个数据就进行==即时处理==，在任何一个地方中止输入，算法都能正确地给出当前的解



## 线性结构

### 引子

- 多项式表示

​	关键信息

​	1.多项式项数n

​	2.各项系数a~i~及指数i



- 方法1：顺序存储结构直接表示

数组各分量对应多项式各项

​	a[i]：项x^i^的系数a~i~

e.g. 

f(x)=4x^5^-3x^2^+1 表示成：

| 下标i | 0    | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| a[i]  | 1    | 0    | -3   | 0    | 0    | 4    |

问题：零项浪费空间



- 方法2：顺序存储结构表示非零项

每个非零项a~i~x^i^涉及两个信息：系数a~i~和指数i

可以将一个多项式看作为(a~i~，i)二元组的集合

用结构数组表示：数组分量是由系数a~i~和指数i组成的结构，对应一个非零项

e.g.

p(x)=9x^12^+15x^8^+3x^2^ 表示成：

| 下标i    | 0    | 1    | 2    |
| -------- | ---- | ---- | ---- |
| 系数a~i~ | 9    | 15   | 3    |
| 指数i    | 12   | 8    | 2    |



- 方法3：链表结构存储非零项

链表中每个==结点==存储多项式中的一个非零项，包括==系数和指数==两个数据以及一个==指针域==

| coef | expon | link |
| ---- | ----- | ---- |

```c
typedef struct PolyNode *Polynominal;
struct PolyNode{
    int coef;
    int expon;
    Polynomial link;
}
```

### 线性表

- 多项式问题启示
  - 同一个问题可以有不同的表示（存储）方法
  - 有一类共性问题：有序线性序列的组织和管理



- 线性表定义

线性表(linera list) 是由**同类型数据元素**构成**有序序列**的线性结构

​	> 表中元素个数称为线性表长度

​	> 线性表没有元素时，称为空表

​	> 表起始位置称表头，表结束位置称表尾

